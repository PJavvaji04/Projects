# -*- coding: utf-8 -*-
"""Drug Prescription.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P0-FMPDhIxsHYnhmBU94Ydlzc1WiwARJ
"""

import pandas as pd
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import ipywidgets as widgets
from wordcloud import WordCloud
import nltk
from nltk.sentiment.vader import SentimentIntensityAnalyzer
from IPython.display import display, HTML, clear_output
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

data = pd.read_csv('drug.csv')

data.head(5)

data[['rating','usefulCount']].describe()

data.info()

uni = data.nunique()
print('--Unique Values in the Dataset--\n')
print(uni)

drug = data['drugName'].value_counts().head(20)
plt.figure(figsize=(10,5))
plt.title('Top 20 Drug Names')
drug.plot(kind='bar')
plt.xlabel('Drug Name')
plt.ylabel('Count')
plt.show()

condi =" ".join(data['condition'].dropna().astype(str))

condi_cloud = WordCloud(width=500, height=500,background_color="white").generate(condi)
plt.figure(figsize=(20,10))
plt.title("Word Cloud of Conditions")
plt.imshow(condi_cloud, interpolation="bilinear")
plt.axis("off")
plt.show()

cond = data['condition'].value_counts().head(20)
plt.figure(figsize=(10,5))
plt.title('Top 20 Medical Conditions')
cond.plot(kind='bar')
plt.xlabel('Medical Condition')
plt.ylabel('Count')
plt.show()

rev = " ".join(data['review'])

rev_cloud = WordCloud(width=500, height=500,background_color="White").generate(rev)

plt.figure(figsize=(20,10))
plt.imshow(rev_cloud,interpolation="bilinear")
plt.axis("off")
plt.title("Word Cloud of Reviews")
plt.show()

data['review'] = data['review'].str.replace(r'[^\w\s]', '', regex=True)

data_cleaned = data.dropna(subset=['condition'])

data_cleaned.info()

data_cleaned.duplicated()

# 2. Sentiment Analysis using VADER

nltk.download('vader_lexicon')

# Make sure data_cleaned is a standalone copy
data_cleaned = data_cleaned.copy()

# Initialize the sentiment analyzer
sia = SentimentIntensityAnalyzer()

# Compute sentiment scores for each review using .loc
data_cleaned.loc[:, 'compound'] = data_cleaned['review'].apply(lambda x: sia.polarity_scores(x)['compound'])

# Define a function to assign sentiment labels based on the compound score
def label_sentiment(score):
    if score >= 0.05:
        return 'positive'
    elif score <= -0.05:
        return 'negative'
    else:
        return 'neutral'

# Create a new column with sentiment labels using .loc
data_cleaned.loc[:, 'sentiment'] = data_cleaned['compound'].apply(label_sentiment)

plt.figure(figsize=(8,6))
ax = sns.countplot(x='sentiment', data=data_cleaned, order=['positive', 'neutral', 'negative'], hue='sentiment', palette="Set2", dodge=False)
plt.title("Sentiment Distribution (VADER)")
plt.xlabel("Sentiment")
plt.ylabel("Count")
plt.show()

# Prepare text data using TF-IDF vectorization
tfidf = TfidfVectorizer(max_features=5000, stop_words='english')
X = tfidf.fit_transform(data_cleaned['review'])
y = data_cleaned['sentiment']

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# --- (A) Logistic Regression Model ---
lr_model = LogisticRegression(max_iter=1000)
lr_model.fit(X_train, y_train)
y_pred_lr = lr_model.predict(X_test)
accuracy_lr = accuracy_score(y_test, y_pred_lr)
print("Logistic Regression Accuracy:", accuracy_lr)
print("Classification Report (Logistic Regression):\n", classification_report(y_test, y_pred_lr))

# --- (B) Random Forest Classifier ---
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)
accuracy_rf = accuracy_score(y_test, y_pred_rf)
print("Random Forest Accuracy:", accuracy_rf)
print("Classification Report (Random Forest):\n", classification_report(y_test, y_pred_rf))

# Function to plot confusion matrix
def plot_confusion_matrix(cm, classes, title):
    plt.figure(figsize=(6,6))
    sns.heatmap(cm, annot=True, fmt="d", cmap=plt.cm.Blues,
                xticklabels=classes, yticklabels=classes)
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title(title)
    plt.show()

cm_lr = confusion_matrix(y_test, y_pred_lr, labels=['positive','neutral','negative'])
plot_confusion_matrix(cm_lr, classes=['positive','neutral','negative'], title='Confusion Matrix: Logistic Regression')

cm_rf = confusion_matrix(y_test, y_pred_rf, labels=['positive','neutral','negative'])
plot_confusion_matrix(cm_rf, classes=['positive','neutral','negative'], title='Confusion Matrix: Random Forest')

# 4. Drug Recommendation

# Ensure 'rating' is numeric
data_cleaned['rating'] = pd.to_numeric(data_cleaned['rating'], errors='coerce')

drug_agg = data_cleaned.groupby(['condition', 'drugName']).agg({
    'rating': 'mean',
    'usefulCount': 'sum',
    'review': 'first'
}).reset_index()

# HTML Widget Setup for Condition Search

condition_input = widgets.Text(
    description='condition:',
    placeholder='Enter a medical condition'
)

# Create a search button widget
search_button = widgets.Button(
    description='Search',
    button_style='primary'
)

output = widgets.Output()

# Function to handle search button click
def search_button_clicked(b):
    with output:
        clear_output()  # Clear previous output
        condition = condition_input.value.strip().lower()

        if condition == "":
            display(HTML("<h3>Please enter a condition.</h3>"))
            return

        # Filter dataset by condition (case-insensitive, partial match)
        drug_subset = drug_agg[drug_agg['condition'].str.lower().str.contains(condition, na=False)].copy()

        if drug_subset.empty:
            display(HTML(f"<h3>No records found for condition: {condition.capitalize()}</h3>"))
            return

        # Rank drugs by average rating (simple recommendation strategy)
        drug_subset = drug_subset.sort_values(by='rating', ascending=False)
        top5_drugs = drug_subset.head(5)

        # Display the top 5 drugs in an HTML table (showing condition, drugName, rating, usefulCount, and review)
        display(HTML(f"<h3>Top 5 Drugs for Condition: {condition.capitalize()}</h3>"))
        display(HTML(top5_drugs[['condition', 'drugName', 'rating', 'usefulCount', 'review']].to_html(index=False)))

# Bind the search button to the click event
search_button.on_click(search_button_clicked)

display(condition_input, search_button, output)